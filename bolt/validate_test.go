package bolt

import (
	"testing"
)

func TestParsingReadMode(t *testing.T) {
	// BEGIN { "mode": "r" }
	buf := []byte{0x00, 0x0a, 0xb1, 0x11, 0xa1, 0x84, 0x6d, 0x6f, 0x64, 0x65, 0x81, 0x72, 0x0, 0x0}

	mode, err := ValidateMode(buf)
	if err != nil {
		t.Fatalf("failed to parse mode: %v", err)
	}
	if mode != ReadMode {
		t.Fatalf("expected to see a read mode")
	}
}

func TestParsingEmptyMode(t *testing.T) {
	// BEGIN { }
	buf := []byte{0x00, 0x03, 0xb1, 0x11, 0xa0, 0x0, 0x0}

	mode, err := ValidateMode(buf)
	if err != nil {
		t.Fatalf("failed to parse mode: %v", err)
	}
	if mode != WriteMode {
		t.Fatalf("expected to see a write mode")
	}
}

func TestParsingFailure(t *testing.T) {
	// FAILURE {'code': 'Neo.ClientError.Security.Unauthorized',
	// 'message': 'The client is unauthorized due to authentication failure.'}
	buf := []byte{
		0xa2, 0x84, 0x63, 0x6f, 0x64, 0x65, 0xd0, 0x25,
		0x4e, 0x65, 0x6f, 0x2e, 0x43, 0x6c, 0x69, 0x65,
		0x6e, 0x74, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x2e,
		0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79,
		0x2e, 0x55, 0x6e, 0x61, 0x75, 0x74, 0x68, 0x6f,
		0x72, 0x69, 0x7a, 0x65, 0x64, 0x87, 0x6d, 0x65,
		0x73, 0x73, 0x61, 0x67, 0x65, 0xd0, 0x39, 0x54,
		0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e,
		0x74, 0x20, 0x69, 0x73, 0x20, 0x75, 0x6e, 0x61,
		0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x65,
		0x64, 0x20, 0x64, 0x75, 0x65, 0x20, 0x74, 0x6f,
		0x20, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74,
		0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20,
		0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x2e,
		0x0, 0x0}

	result, _, err := ParseTinyMap(buf)
	if err != nil {
		t.Fatal("failed to parse tiny map")
	}
	val, ok := result["message"]
	if !ok {
		t.Fatal("failed to find 'message' in tiny map")
	}
	msg, ok := val.(string)
	if !ok {
		t.Fatalf("expected a string value, saw: %v", val)
	}
	if msg != "The client is unauthorized due to authentication failure." {
		t.Fatal("unexpected message:", val)
	}
}
