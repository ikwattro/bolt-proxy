package main

import (
	"testing"
)

func TestParsingReadMode(t *testing.T) {
	// BEGIN { "mode": "r" }
	buf := []byte{0xa1, 0x84, 0x6d, 0x6f, 0x64, 0x65, 0x81, 0x72, 0x0, 0x0}

	result, err := parseTinyMap(buf)
	if err != nil {
		t.Fatalf("failed to parse read transaction's tiny map: %v", err)
	}
	val, ok := result["mode"]
	if !ok {
		t.Fatalf("failed to find a 'mode' key in tiny map")
	}

	if len(val) != 1 || val[0] != 'r' {
		t.Fatalf("mode value isn't a single byte 'r'")
	}
}

func TestParsingEmptyMode(t *testing.T) {
	// BEGIN { }
	buf := []byte{0xa0, 0x0, 0x0}

	result, err := parseTinyMap(buf)
	if err != nil {
		t.Fatalf("failed to parse read transaction's tiny map: %v", err)
	}
	if len(result) != 0 {
		t.Fatalf("expected empty tiny map")
	}
}

func TestParsingFailure(t *testing.T) {
	// FAILURE {'code': 'Neo.ClientError.Security.Unauthorized',
	// 'message': 'The client is unauthorized due to authentication failure.'}
	buf := []byte{
		0xa2, 0x84, 0x63, 0x6f, 0x64, 0x65, 0xd0, 0x25,
		0x4e, 0x65, 0x6f, 0x2e, 0x43, 0x6c, 0x69, 0x65,
		0x6e, 0x74, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x2e,
		0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79,
		0x2e, 0x55, 0x6e, 0x61, 0x75, 0x74, 0x68, 0x6f,
		0x72, 0x69, 0x7a, 0x65, 0x64, 0x87, 0x6d, 0x65,
		0x73, 0x73, 0x61, 0x67, 0x65, 0xd0, 0x39, 0x54,
		0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e,
		0x74, 0x20, 0x69, 0x73, 0x20, 0x75, 0x6e, 0x61,
		0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x65,
		0x64, 0x20, 0x64, 0x75, 0x65, 0x20, 0x74, 0x6f,
		0x20, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74,
		0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20,
		0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x2e,
		0x0, 0x0}

	result, err := parseTinyMap(buf)
	if err != nil {
		t.Fatal("failed to parse tiny map")
	}
	val, ok := result["message"]
	if !ok {
		t.Fatal("failed to find 'message' in tiny map")
	}
	s := string(val)
	if s != "The client is unauthorized due to authentication failure." {
		t.Fatal("unexpected message:", val)
	}
}
